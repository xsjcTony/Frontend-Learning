# 通用知识



## JSON Schema

[JSON Schema | The home of JSON Schema](https://json-schema.org/)

- 定义了 `JSON` 格式的规范



### 校验

[ajv - npm](https://www.npmjs.com/package/ajv)

[Ajv JSON schema validator](https://ajv.js.org/)

- 使用 `ajv` 完成
- 在 `Egg` 中使用 `egg-ajv` [egg-ajv - npm](https://www.npmjs.com/package/egg-ajv) , 在 `controller` 层校验

安装

```shell
npm i ajv
```

基本使用

```js
import Ajv from 'ajv'
import schema from '/path/to/schema.js'

const ajv = new Ajv()

const validate = ajv.compile(schema)
const valid = validate(data) // true or false

if (!valid) { console.log(validate.errors) }
```

---

## 后端结构分层

![general_backend_hierarchy.png](D:\xsjcTony\it666\Frontend-Learning\Notes\服务端\images\general_backend_hierarchy.png)

---

## 密码加密

[Crypto | Node.js v16.13.2 Documentation](https://nodejs.org/dist/latest-v16.x/docs/api/crypto.html)

- 使用 `NodeJS` 的 `Crypto` 模块



### 加密方式



#### md5

- 全称为 `Message-Digest Algorithm 5`

- 一种不可逆的加密方式
- 会生成一个 `128` 位长度的 `Hash`
- <span style="color: #f90;">可以被暴力破解, 所以需要对 `原始数据` 进行 `加盐` 处理</span>
  - 给 `原始数据` 混入一些 `其他数据`

```js
import { createHash } from 'crypto'

const salt = 'TonyLovesLily'

/**
 * Encrypt password by MD5 algorithm
 * @param password
 * @return {string}
 * @private
 */
const _md5 = (password) => {
  return createHash('md5')
    .update(password)
    .digest('hex')
}

/**
 * Encrypt password by adding salt & MD5 algorithm
 * @param {string} password
 * @return {string}
 */
export const encryptPasswordByMd5 = (password) => {
  // 加盐处理
  return _md5(password + salt)
}
```

---

## 存储用户登录状态



### 客户端保存

方案

- 使用 `Cookie`
  - 在 `客户端` / `服务端` 都可以对 `Cookie` 进行增删改查
  - 每次发送网络请求时, `客户端` 都会自动将当前域名的 `Cookie` 发送给服务端

#### 安全隐患

- 由于 `Cookie` 可以在 `客户端` 修改, 所以需要设置 `httpOnly` 防止在客户端被修改
- 需要给 `Cookie` 设置 `expires` 过期时间
- 需要给 `Cookie` 中的明文加密

```js
import { loginUser } from '../controller/userController.js'
import { encryptByMd5 } from '../utils/crypto.js'

const _generateCookieExpires = () => {
  const date = new Date()
  date.setTime(date.getTime() + (24 * 60 * 60 * 1000))
  return date.toUTCString()
}

export const userRouterHandler = async (req, res) => {
  if (req.method === 'post' && req.path === USER_LOGIN) {
    // login attempt
    const result = await loginUser(req.body)
    
    // save login status
    if (result.code === 200) {
      res.setHeader('Set-Cookie', `username=${ encryptByMd5(result.data.username) }; path=/; httpOnly; expires=${ _generateCookieExpires() }`)
    }
    
    return result
  }
}
```



### 服务端保存

`客户端` 保存登录状态的不足

- 由于存储的可能不止用户名, `Cookie` 可能会出现存不下的情况
- 由于 `客户端` 中的数据加密, 还需要在 `服务端` 存储加密映射关系

方案

- 使用 `Session`
  - 给每一个用户分配一个 `无关紧要` 的值作为 `唯一标识` , 存在 `Cookie` 中
  - 在 `服务端` 定义一个 `全局变量` 作为 `Session容器` (建议使用 `Redis` 代替, 见下文 `解决方案 `)
  - 将用户的 `唯一标识` 作为 `key` , 用户登录之后就给容器的这个 `key` 添加登录状态信息

```js
/**
 * Initialize cookie and session, store user's login status in `req.session`
 * @param req
 * @param res
 * @private
 */
const _initCookieAndSession = (req, res) => {
  // Cookie
  req.cookie = cookieToObject(req.headers.cookie)

  // 用户标识
  req.userId = req.cookie.userId

  if (!req.userId) {
    req.userId = `${ Date.now() }_${ Math.random() }_Aelita`

    res.setHeader('Set-Cookie', `userId=${ req.userId }; path=/; httpOnly; expires=${ generateCookieExpires(24) }`)

    SESSION_CONTAINER[req.userId] = {}
  }

  SESSION_CONTAINER[req.userId] = SESSION_CONTAINER[req.userId] ?? {}

  req.session = SESSION_CONTAINER[req.userId]
  console.log(req.session)
}
```

```js
// /api/user/login
if (req.method === 'post' && req.path === USER_LOGIN) {
  const result = await loginUser(req.body)

  if (result.code === 200) {
    req.session.id = result.data.id
    req.session.username = result.data.username
    req.session.gender = result.data.gender
  }

  return result
}
```

#### 问题

- `全局变量` 会占用当前应用程序分配到的 `存储空间` , 可能会出现存不下的情况
  - `32-bit` 操作系统是 `1.6GB`
  - `64-bit` 操作系统是 `3GB`
- `全局变量` 中存储的数据会随着服务端应用程序的重启而消失, 导致频繁要求用户登录, 带来不好的用户体验
- 一般一台服务器会运行多个 `NodeJS` 进程, 但是无法互相访问其他进程的 `内存` , 导致登录状态无法共享

#### 解决方案

- 使用 `Redis`
  - 可以搭建 `集群` , 突破 `内存大小` 的限制
  - 只要不重启数据就不会消失
  - 无论哪个 `NodeJS` 进程都可以访问 `Redis` 中的数据, 解决共享问题
  - 性能极好, 速度极快

```js
import redis from './database/redis.js'

/**
 * Initialize cookie and session, store user's login status in `req.session`
 * @param req
 * @param res
 * @private
 */
const _initCookieAndSession = async (req, res) => {
  // Cookie
  req.cookie = cookieToObject(req.headers.cookie)

  // 用户标识
  req.userId = req.cookie.userId

  if (!req.userId) {
    req.userId = `${ Date.now() }_${ Math.random() }_Aelita`

    res.setHeader('Set-Cookie', `userId=${ req.userId }; path=/; httpOnly; expires=${ generateCookieExpires(24) }`)

    req.session = {}
  }

  req.session = req.session ?? await redis.get(req.userId) ?? {}
}
```

```js
// /api/user/login
if (req.method === 'post' && req.path === USER_LOGIN) {
  // login attempt
  const result = await loginUser(req.body)

  // save login status
  if (result.code === 200) {
    req.session.id = result.data.id
    req.session.username = result.data.username
    req.session.gender = result.data.gender

    await redis.set(req.userId, req.session)
  }

  return result
}
```

---

## SQL注入攻击

[What is SQL Injection | SQLI Attack Example &amp; Prevention Methods | Imperva](https://www.imperva.com/learn/application-security/sql-injection-sqli/#:~:text=SQL%20injection%2C%20also%20known%20as,lists%20or%20private%20customer%20details.)

定义

- 一种古老的攻击方式
- 利用一些 `SQL` 查询语句的漏洞, 让应用程序执行不正确的 `SQL` 语句的一种攻击方式

解决方案

- 使用 `mysql2` 库中的 `escape` 方法处理所有用户提供的数据, 注意他的返回值自带 `''` 引号
- 直接使用 `Sequelize`

---

## 日志

定义

- 记录用户操作 / 系统运行状态 / 错误信息
- 日志记录的好坏直接关系到系统出现问题时定位的速度
- 如果没有日志, 就相当于人没有眼睛
- 可以分析用户行为
- 可以排查项目上线之后的一些错误



### 常见日志

- 访问日志
- 错误日志
- 安全日志



### 手动实现

访问日志

```js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'


const __dirname = path.dirname(fileURLToPath(import.meta.url))


// helper functions
const _createDirPath = () => {
  const date = new Date()
  const dirName = `${ date.getFullYear() }_${ date.getMonth() + 1 }_${ date.getDay() }`
  const fullPath = path.join(__dirname, '../log', dirName)

  if (!fs.existsSync(fullPath)) {
    fs.mkdirSync(fullPath)
  }

  return fullPath
}


const _createWriteStream = () => {
  const fullPath = _createDirPath()
  const fullFileName = path.join(fullPath, 'access.log')

  return fs.createWriteStream(fullFileName, { flags: 'a' })
}


// main functions
const writeStream = _createWriteStream()
const writeLog = (log) => {
  writeStream.write(`${ log }\n`)
}

export default writeLog
```

```js
// 写入日志
 writeLog(`${ new Date().toTimeString() }   ${ req.method }   ${ req.url }   ${ req.headers['user-agent'] }`)
```



### 分析日志

- 重点是使用 `readline` 模块读取数据

```js
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import readline from 'readline'


const __dirname = path.dirname(fileURLToPath(import.meta.url))


// helper functions
const _dirPath = () => {
  const date = new Date()
  const dirName = `${ date.getFullYear() }_${ date.getMonth() + 1 }_${ date.getDay() }`
  return path.join(__dirname, '../log', dirName)
}


const _createReadStream = () => {
  const fullFileName = path.join(_dirPath(), 'access.log')

  return fs.createReadStream(fullFileName)
}


// main functions
const readStream = _createReadStream()

readStream.on('error', (err) => { console.error(err) })

let totalCount = 0
let chromeCount = 0

const rl = readline.createInterface({ input: readStream })
rl.on('line', (line) => {
  if (!line) { return }
  totalCount++
  if (line.includes('Chrome')) { chromeCount++ }
})
rl.on('close', () => {
  console.log(`${ chromeCount / totalCount * 100 }%`)
})
```

---

## Cookie跨域

- 在前后端分离开发中, `cookie` 会出现跨域的情况, 比如
  - 前端: `http://192.168.0.107:3001`
  - 后端: `http://127.0.0.1:3000`
- 可以使用 `Nginx` 进行 `反向代理` 解决
- `Nginx` 相关见 `Nginx.md`

![nginx_cookie.png](D:\xsjcTony\it666\Frontend-Learning\Notes\服务端\images\nginx_cookie.png)



### 正向代理

定义

- 代理服务器为 `用户` 服务
- 比如在国内访问 `谷歌` , 用户先访问 `海外的服务器` , 再通过 `海外的服务器` 访问 `谷歌`

用途

- 访问原来无法访问的资源, 比如国内访问 `谷歌`
- 对客户端访问授权, 进行上网认证

图示

![forward_proxy.png](D:\xsjcTony\it666\Frontend-Learning\Notes\服务端\images\forward_proxy.png)



### 反向代理

定义

- 代理服务器为 `服务器` 服务

用途

- 负载均衡, 优化网站的负载
- 前后端分离, 统一请求地址

图示

![reverse_proxy.png](D:\xsjcTony\it666\Frontend-Learning\Notes\服务端\images\reverse_proxy.png)

---

## 错误代码

| Status Code | Constructor Name              |
| ----------- | ----------------------------- |
| 400         | BadRequest                    |
| 401         | Unauthorized                  |
| 402         | PaymentRequired               |
| 403         | Forbidden                     |
| 404         | NotFound                      |
| 405         | MethodNotAllowed              |
| 406         | NotAcceptable                 |
| 407         | ProxyAuthenticationRequired   |
| 408         | RequestTimeout                |
| 409         | Conflict                      |
| 410         | Gone                          |
| 411         | LengthRequired                |
| 412         | PreconditionFailed            |
| 413         | PayloadTooLarge               |
| 414         | URITooLong                    |
| 415         | UnsupportedMediaType          |
| 416         | RangeNotSatisfiable           |
| 417         | ExpectationFailed             |
| 418         | ImATeapot                     |
| 421         | MisdirectedRequest            |
| 422         | UnprocessableEntity           |
| 423         | Locked                        |
| 424         | FailedDependency              |
| 425         | TooEarly                      |
| 426         | UpgradeRequired               |
| 428         | PreconditionRequired          |
| 429         | TooManyRequests               |
| 431         | RequestHeaderFieldsTooLarge   |
| 451         | UnavailableForLegalReasons    |
| 500         | InternalServerError           |
| 501         | NotImplemented                |
| 502         | BadGateway                    |
| 503         | ServiceUnavailable            |
| 504         | GatewayTimeout                |
| 505         | HTTPVersionNotSupported       |
| 506         | VariantAlsoNegotiates         |
| 507         | InsufficientStorage           |
| 508         | LoopDetected                  |
| 509         | BandwidthLimitExceeded        |
| 510         | NotExtended                   |
| 511         | NetworkAuthenticationRequired |















