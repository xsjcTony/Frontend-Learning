const fs = require('fs')
const ejs = require('ejs')
const path = require('path')
const babel = require('@babel/core')
const t = require('@babel/types')
const { SyncHook, SyncBailHook } = require('tapable')

class Compiler {
  constructor (options) {
    // save webpack configuration
    this.options = options
    // save modules by { path as key, code as value }
    this.modules = {}
    // create hooks
    this.hooks = {
      entryOption: new SyncBailHook(),
      done: new SyncHook()
    }
    // save plugins, invoke apply() method and pass compiler in
    const plugins = this.options.plugins
    plugins.forEach((plugin) => { plugin.apply(this) })
  }

  run (path) {
    this.buildModule(this.options.entry)
    this.emitFile()
    // trigger done hook
    this.hooks.done.call()
  }

  buildModule (modulePath) {
    const code = this.getSource(modulePath)
    // change current module's code
    const { result, dependencies } = this.parseModule(code)
    // save entry module code into modules
    this.modules[modulePath] = result
    // save dependencies into modules
    dependencies.forEach((dependencyPath) => {
      this.buildModule(dependencyPath)
    })
  }

  parseModule (code) {
    const rootPath = path.dirname(this.options.entry)
    const dependencies = []
    // code => AST
    const ast = babel.parse(code)
    // modify AST
    babel.traverse(ast, {
      CallExpression (nodePath) {
        const node = nodePath.node
        if (node.callee.name === 'require') {
          // require => __webpack_require__
          node.callee.name = '__webpack_require__'
          // change file path
          let modulePath = node.arguments[0].value
          modulePath = '.\\' + path.join(rootPath, modulePath)
          modulePath = modulePath.replace(/\\/g, '/')
          dependencies.push(modulePath)
          node.arguments[0] = t.StringLiteral(modulePath)
        }
      }
    })
    // AST => code
    const { code: result } = babel.transformFromAstSync(ast)
    return { result, dependencies }
  }

  getSource (path) {
    let content = fs.readFileSync(path, 'utf-8')
    // check if loader is needed
    if (!this.options.modules?.rules) { return content }
    const rules = this.options.module.rules
    rules.forEach(({ test, use }) => {
      if (test.test(path)) {
        // loader needed
        [...use].reverse().forEach((loaderPath) => { // traverse loaders from the last to the first
          const loader = require(loaderPath)
          content = loader(content)
        })
      }
    })

    return content
  }

  emitFile () {
    // get ejs template
    const template = fs.readFileSync(path.resolve(__dirname, 'main.ejs'), 'utf-8')
    // replace contents in the template
    const code = ejs.render(template, { entryId: this.options.entry, modules: this.modules })
    // write result into file
    const outputDir = this.options.output.path
    // create output directory if not exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir)
    }
    fs.writeFileSync(path.resolve(outputDir, this.options.output.filename), code)
  }
}

module.exports = Compiler
